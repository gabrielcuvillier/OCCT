// This file has been automatically generated from resource file src/Shaders/RaytraceBase.fs

static const char Shaders_RaytraceBase_fs[] =
  "#ifdef ADAPTIVE_SAMPLING\n"
  "  #extension GL_ARB_shader_image_load_store : require\n"
  "#endif\n"
  "#ifdef ADAPTIVE_SAMPLING_ATOMIC\n"
  "  #extension GL_NV_shader_atomic_float : require\n"
  "#endif\n"
  "#ifdef USE_TEXTURES\n"
  "  #extension GL_ARB_bindless_texture : require\n"
  "#endif\n"
  "in vec2 vPixel;\n"
  "uniform vec2 uFsaaOffset;\n"
  "uniform float uOffsetY;\n"
  "uniform vec3 uOriginLT;\n"
  "uniform vec3 uOriginLB;\n"
  "uniform vec3 uOriginRT;\n"
  "uniform vec3 uOriginRB;\n"
  "uniform int uWinSizeX;\n"
  "uniform int uWinSizeY;\n"
  "uniform vec3 uDirectLT;\n"
  "uniform vec3 uDirectLB;\n"
  "uniform vec3 uDirectRT;\n"
  "uniform vec3 uDirectRB;\n"
  "uniform mat4 uUnviewMat;\n"
  "uniform mat4 uViewMat;\n"
  "uniform isamplerBuffer uSceneNodeInfoTexture;\n"
  "uniform samplerBuffer uSceneMinPointTexture;\n"
  "uniform samplerBuffer uSceneMaxPointTexture;\n"
  "uniform samplerBuffer uSceneTransformTexture;\n"
  "uniform samplerBuffer uGeometryVertexTexture;\n"
  "uniform samplerBuffer uGeometryNormalTexture;\n"
  "#ifdef USE_TEXTURES\n"
  "  //! Texture buffer of per-vertex UV-coordinates.\n"
  "  uniform samplerBuffer uGeometryTexCrdTexture;\n"
  "#endif\n"
  "uniform isamplerBuffer uGeometryTriangTexture;\n"
  "uniform samplerBuffer uRaytraceMaterialTexture;\n"
  "uniform samplerBuffer uRaytraceLightSrcTexture;\n"
  "#ifdef BACKGROUND_CUBEMAP\n"
  "  //! Environment cubemap texture.\n"
  "  uniform samplerCube uEnvMapTexture;\n"
  "  //! Coefficient of Y controlling horizontal flip of cubemap\n"
  "  uniform int uYCoeff;\n"
  "  //! Coefficient of Z controlling vertical flip of cubemap\n"
  "  uniform int uZCoeff;\n"
  "#else\n"
  "  //! Environment map texture.\n"
  "  uniform sampler2D uEnvMapTexture;\n"
  "#endif\n"
  "uniform int uLightCount;\n"
  "uniform vec4 uGlobalAmbient;\n"
  "uniform int uShadowsEnabled;\n"
  "uniform int uReflectEnabled;\n"
  "uniform int uEnvMapEnabled;\n"
  "uniform int uEnvMapForBack;\n"
  "uniform float uSceneRadius;\n"
  "uniform float uSceneEpsilon;\n"
  "#ifdef USE_TEXTURES\n"
  "  //! Unique 64-bit handles of OpenGL textures.\n"
  "  uniform uvec2 uTextureSamplers[MAX_TEX_NUMBER];\n"
  "#endif\n"
  "#ifdef ADAPTIVE_SAMPLING\n"
  "  //! OpenGL image used for accumulating rendering result.\n"
  "  volatile restrict layout(r32f) uniform image2D  uRenderImage;\n"
  "#ifdef ADAPTIVE_SAMPLING_ATOMIC\n"
  "  //! OpenGL image storing offsets of sampled pixels blocks.\n"
  "  coherent restrict layout(rg32i) uniform iimage2D uOffsetImage;\n"
  "#else\n"
  "  //! OpenGL image defining per-tile amount of samples.\n"
  "  volatile restrict layout(r32i) uniform iimage2D uTilesImage;\n"
  "#endif\n"
  "  //! Screen space tile size.\n"
  "  uniform ivec2 uTileSize;\n"
  "#endif\n"
  "uniform vec4 uBackColorTop;\n"
  "uniform vec4 uBackColorBot;\n"
  "uniform float uApertureRadius;\n"
  "uniform float uFocalPlaneDist;\n"
  "uniform vec3 uEyeOrig;\n"
  "uniform vec3 uEyeView;\n"
  "uniform vec3 uEyeVert;\n"
  "uniform vec3 uEyeSide;\n"
  "uniform vec2 uEyeSize;\n"
  "/////////////////////////////////////////////////////////////////////////////////////////\n"
  "struct SRay\n"
  "{\n"
  "  vec3 Origin;\n"
  "  vec3 Direct;\n"
  "};\n"
  "struct SIntersect\n"
  "{\n"
  "  float Time;\n"
  "  vec2 UV;\n"
  "  vec3 Normal;\n"
  "};\n"
  "struct STriangle\n"
  "{\n"
  "  ivec4 TriIndex;\n"
  "  vec3 Points[3];\n"
  "};\n"
  "/////////////////////////////////////////////////////////////////////////////////////////\n"
  "#define MAXFLOAT 1e15f\n"
  "#define SMALL vec3 (exp2 (-80.0f))\n"
  "#define ZERO vec3 (0.0f, 0.0f, 0.0f)\n"
  "#define UNIT vec3 (1.0f, 1.0f, 1.0f)\n"
  "#define AXIS_X vec3 (1.0f, 0.0f, 0.0f)\n"
  "#define AXIS_Y vec3 (0.0f, 1.0f, 0.0f)\n"
  "#define AXIS_Z vec3 (0.0f, 0.0f, 1.0f)\n"
  "#define M_PI   3.141592653f\n"
  "#define M_2_PI 6.283185307f\n"
  "#define M_PI_2 1.570796327f\n"
  "#define LUMA vec3 (0.2126f, 0.7152f, 0.0722f)\n"
  "vec3 MatrixRowMultiplyDir (in vec3 v,\n"
  "                           in vec4 m0,\n"
  "                           in vec4 m1,\n"
  "                           in vec4 m2)\n"
  "{\n"
  "  return vec3 (dot (m0.xyz, v),\n"
  "               dot (m1.xyz, v),\n"
  "               dot (m2.xyz, v));\n"
  "}\n"
  "uint RandState;\n"
  "void SeedRand (in int theSeed, in int theSizeX, in int theRadius)\n"
  "{\n"
  "  RandState = uint (int (gl_FragCoord.y) / theRadius * theSizeX + int (gl_FragCoord.x) / theRadius + theSeed);\n"
  "  RandState = (RandState + 0x479ab41du) + (RandState <<  8);\n"
  "  RandState = (RandState ^ 0xe4aa10ceu) ^ (RandState >>  5);\n"
  "  RandState = (RandState + 0x9942f0a6u) - (RandState << 14);\n"
  "  RandState = (RandState ^ 0x5aedd67du) ^ (RandState >>  3);\n"
  "  RandState = (RandState + 0x17bea992u) + (RandState <<  7);\n"
  "}\n"
  "uint RandInt()\n"
  "{\n"
  "  RandState ^= (RandState << 13);\n"
  "  RandState ^= (RandState >> 17);\n"
  "  RandState ^= (RandState <<  5);\n"
  "  return RandState;\n"
  "}\n"
  "float RandFloat()\n"
  "{\n"
  "  return float (RandInt()) * (1.f / 4294967296.f);\n"
  "}\n"
  "vec3 MatrixColMultiplyPnt (in vec3 v,\n"
  "                           in vec4 m0,\n"
  "                           in vec4 m1,\n"
  "                           in vec4 m2,\n"
  "                           in vec4 m3)\n"
  "{\n"
  "  return vec3 (m0.x * v.x + m1.x * v.y + m2.x * v.z + m3.x,\n"
  "               m0.y * v.x + m1.y * v.y + m2.y * v.z + m3.y,\n"
  "               m0.z * v.x + m1.z * v.y + m2.z * v.z + m3.z);\n"
  "}\n"
  "vec3 MatrixColMultiplyDir (in vec3 v,\n"
  "                           in vec4 m0,\n"
  "                           in vec4 m1,\n"
  "                           in vec4 m2)\n"
  "{\n"
  "  return vec3 (m0.x * v.x + m1.x * v.y + m2.x * v.z,\n"
  "               m0.y * v.x + m1.y * v.y + m2.y * v.z,\n"
  "               m0.z * v.x + m1.z * v.y + m2.z * v.z);\n"
  "}\n"
  "//=======================================================================\n"
  "//=======================================================================\n"
  "vec3 InverseDirection (in vec3 theInput)\n"
  "{\n"
  "  vec3 anInverse = 1.f / max (abs (theInput), SMALL);\n"
  "  return mix (-anInverse, anInverse, step (ZERO, theInput));\n"
  "}\n"
  "//=======================================================================\n"
  "//=======================================================================\n"
  "vec4 BackgroundColor()\n"
  "{\n"
  "#ifdef ADAPTIVE_SAMPLING_ATOMIC\n"
  "  ivec2 aFragCoord = ivec2 (gl_FragCoord.xy);\n"
  "  ivec2 aTileXY = imageLoad (uOffsetImage, aFragCoord / uTileSize).xy * uTileSize;\n"
  "  aTileXY.y += aFragCoord.y % min (uWinSizeY - aTileXY.y, uTileSize.y);\n"
  "  return mix (uBackColorBot, uBackColorTop, float (aTileXY.y) / uWinSizeY);\n"
  "#else\n"
  "  return mix (uBackColorBot, uBackColorTop, vPixel.y);\n"
  "#endif\n"
  "}\n"
  "/////////////////////////////////////////////////////////////////////////////////////////\n"
  "//=======================================================================\n"
  "//=======================================================================\n"
  "vec2 sampleUniformDisk ()\n"
  "{\n"
  "  vec2 aPoint;\n"
  "  float aKsi1 = 2.f * RandFloat () - 1.f;\n"
  "  float aKsi2 = 2.f * RandFloat () - 1.f;\n"
  "  if (aKsi1 > -aKsi2)\n"
  "  {\n"
  "    if (aKsi1 > aKsi2)\n"
  "      aPoint = vec2 (aKsi1, (M_PI / 4.f) * (0.f + aKsi2 / aKsi1));\n"
  "    else\n"
  "      aPoint = vec2 (aKsi2, (M_PI / 4.f) * (2.f - aKsi1 / aKsi2));\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    if (aKsi1 < aKsi2)\n"
  "      aPoint = vec2 (-aKsi1, (M_PI / 4.f) * (4.f + aKsi2 / aKsi1));\n"
  "    else\n"
  "      aPoint = vec2 (-aKsi2, (M_PI / 4.f) * (6.f - aKsi1 / aKsi2));\n"
  "  }\n"
  "  return vec2 (sin (aPoint.y), cos (aPoint.y)) * aPoint.x;\n"
  "}\n"
  "SRay GenerateRay (in vec2 thePixel)\n"
  "{\n"
  "#ifndef DEPTH_OF_FIELD\n"
  "  vec3 aP0 = mix (uOriginLB, uOriginRB, thePixel.x);\n"
  "  vec3 aP1 = mix (uOriginLT, uOriginRT, thePixel.x);\n"
  "  vec3 aD0 = mix (uDirectLB, uDirectRB, thePixel.x);\n"
  "  vec3 aD1 = mix (uDirectLT, uDirectRT, thePixel.x);\n"
  "  vec3 aDirection = normalize (mix (aD0, aD1, thePixel.y));\n"
  "  return SRay (mix (aP0, aP1, thePixel.y), aDirection);\n"
  "#else\n"
  "  vec2 aPixel = uEyeSize * (thePixel - vec2 (0.5f)) * 2.f;\n"
  "  vec2 aAperturePnt = sampleUniformDisk () * uApertureRadius;\n"
  "  vec3 aLocalDir = normalize (vec3 (\n"
  "    aPixel * uFocalPlaneDist - aAperturePnt, uFocalPlaneDist));\n"
  "  vec3 aOrigin = uEyeOrig +\n"
  "                 uEyeSide * aAperturePnt.x +\n"
  "                 uEyeVert * aAperturePnt.y;\n"
  "  vec3 aDirect = uEyeView * aLocalDir.z +\n"
  "                 uEyeSide * aLocalDir.x +\n"
  "                 uEyeVert * aLocalDir.y;\n"
  "  return SRay (aOrigin, aDirect);\n"
  "#endif\n"
  "}\n"
  "float IntersectSphere (in SRay theRay, in float theRadius)\n"
  "{\n"
  "  float aDdotD = dot (theRay.Direct, theRay.Direct);\n"
  "  float aDdotO = dot (theRay.Direct, theRay.Origin);\n"
  "  float aOdotO = dot (theRay.Origin, theRay.Origin);\n"
  "  float aD = aDdotO * aDdotO - aDdotD * (aOdotO - theRadius * theRadius);\n"
  "  if (aD > 0.0f)\n"
  "  {\n"
  "    float aTime = (sqrt (aD) - aDdotO) * (1.0f / aDdotD);\n"
  "    \n"
  "    return aTime > 0.0f ? aTime : MAXFLOAT;\n"
  "  }\n"
  "  return MAXFLOAT;\n"
  "}\n"
  "void IntersectTriangle (in SRay theRay,\n"
  "                        in vec3 thePnt0,\n"
  "                        in vec3 thePnt1,\n"
  "                        in vec3 thePnt2,\n"
  "                        out vec3 theUVT,\n"
  "                        out vec3 theNorm)\n"
  "{\n"
  "  vec3 aToTrg = thePnt0 - theRay.Origin;\n"
  "  vec3 aEdge0 = thePnt1 - thePnt0;\n"
  "  vec3 aEdge1 = thePnt0 - thePnt2;\n"
  "  theNorm = cross (aEdge1, aEdge0);\n"
  "  vec3 theVect = cross (theRay.Direct, aToTrg);\n"
  "  theUVT = vec3 (dot (theNorm, aToTrg),\n"
  "                 dot (theVect, aEdge1),\n"
  "                 dot (theVect, aEdge0)) * (1.f / dot (theNorm, theRay.Direct));\n"
  "  theUVT.x = any (lessThan (theUVT, ZERO)) || (theUVT.y + theUVT.z) > 1.f ? MAXFLOAT : theUVT.x;\n"
  "}\n"
  "#define EMPTY_ROOT ivec4(0)\n"
  "struct SSubTree\n"
  "{\n"
  "  //! Transformed ray.\n"
  "  SRay  TrsfRay;\n"
  "  //! Inversed ray direction.\n"
  "  vec3  Inverse;\n"
  "  //! Parameters of sub-root node.\n"
  "  ivec4 SubData;\n"
  "};\n"
  "#define MATERIAL_AMBN(index) (19 * index + 0)\n"
  "#define MATERIAL_DIFF(index) (19 * index + 1)\n"
  "#define MATERIAL_SPEC(index) (19 * index + 2)\n"
  "#define MATERIAL_EMIS(index) (19 * index + 3)\n"
  "#define MATERIAL_REFL(index) (19 * index + 4)\n"
  "#define MATERIAL_REFR(index) (19 * index + 5)\n"
  "#define MATERIAL_TRAN(index) (19 * index + 6)\n"
  "#define MATERIAL_TRS1(index) (19 * index + 7)\n"
  "#define MATERIAL_TRS2(index) (19 * index + 8)\n"
  "#define MATERIAL_TRS3(index) (19 * index + 9)\n"
  "#define TRS_OFFSET(treelet) treelet.SubData.x\n"
  "#define BVH_OFFSET(treelet) treelet.SubData.y\n"
  "#define VRT_OFFSET(treelet) treelet.SubData.z\n"
  "#define TRG_OFFSET(treelet) treelet.SubData.w\n"
  "#define INVALID_HIT ivec4 (-1)\n"
  "int Stack[STACK_SIZE];\n"
  "int pop (inout int theHead)\n"
  "{\n"
  "  int aData = Stack[theHead];\n"
  "  int aMask = aData >> 26;\n"
  "  int aNode = aMask & 0x3;\n"
  "  aMask >>= 2;\n"
  "  if ((aMask & 0x3) == aNode)\n"
  "  {\n"
  "    --theHead;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    aMask |= (aMask << 2) & 0x30;\n"
  "    Stack[theHead] = (aData & 0x03FFFFFF) | (aMask << 26);\n"
  "  }\n"
  "  return (aData & 0x03FFFFFF) + aNode;\n"
  "}\n"
  "STriangle SceneNearestHit (in SRay theRay, in vec3 theInverse, inout SIntersect theHit, out int theTrsfId)\n"
  "{\n"
  "  STriangle aTriangle = STriangle (INVALID_HIT, vec3[](vec3(0.0), vec3(0.0), vec3(0.0)));\n"
  "  int aNode =  0; // node to traverse\n"
  "  int aHead = -1; // pointer of stack\n"
  "  int aStop = -1; // BVH level switch\n"
  "  SSubTree aSubTree = SSubTree (theRay, theInverse, EMPTY_ROOT);\n"
  "  for (bool toContinue = true; toContinue; /* none */)\n"
  "  {\n"
  "    ivec4 aData = texelFetch (uSceneNodeInfoTexture, aNode);\n"
  "    if (aData.x == 0) // if inner node\n"
  "    {\n"
  "      aData.y += BVH_OFFSET (aSubTree);\n"
  "      vec4 aHitTimes = vec4 (MAXFLOAT,\n"
  "                             MAXFLOAT,\n"
  "                             MAXFLOAT,\n"
  "                             MAXFLOAT);\n"
  "      vec3 aRayOriginInverse = -aSubTree.TrsfRay.Origin * aSubTree.Inverse;\n"
  "      vec3 aNodeMin0 = texelFetch (uSceneMinPointTexture, aData.y +                0).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aNodeMin1 = texelFetch (uSceneMinPointTexture, aData.y +                1).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aNodeMin2 = texelFetch (uSceneMinPointTexture, aData.y + min (2, aData.z)).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aNodeMin3 = texelFetch (uSceneMinPointTexture, aData.y + min (3, aData.z)).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aNodeMax0 = texelFetch (uSceneMaxPointTexture, aData.y +                0).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aNodeMax1 = texelFetch (uSceneMaxPointTexture, aData.y +                1).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aNodeMax2 = texelFetch (uSceneMaxPointTexture, aData.y + min (2, aData.z)).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aNodeMax3 = texelFetch (uSceneMaxPointTexture, aData.y + min (3, aData.z)).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aTimeMax = max (aNodeMin0, aNodeMax0);\n"
  "      vec3 aTimeMin = min (aNodeMin0, aNodeMax0);\n"
  "      float aTimeLeave = min (aTimeMax.x, min (aTimeMax.y, aTimeMax.z));\n"
  "      float aTimeEnter = max (aTimeMin.x, max (aTimeMin.y, aTimeMin.z));\n"
  "      aHitTimes.x = (aTimeEnter <= aTimeLeave && aTimeEnter <= theHit.Time && aTimeLeave >= 0.f) ? aTimeEnter : MAXFLOAT;\n"
  "      aTimeMax = max (aNodeMin1, aNodeMax1);\n"
  "      aTimeMin = min (aNodeMin1, aNodeMax1);\n"
  "      aTimeLeave = min (aTimeMax.x, min (aTimeMax.y, aTimeMax.z));\n"
  "      aTimeEnter = max (aTimeMin.x, max (aTimeMin.y, aTimeMin.z));\n"
  "      aHitTimes.y = (aTimeEnter <= aTimeLeave && aTimeEnter <= theHit.Time && aTimeLeave >= 0.f) ? aTimeEnter : MAXFLOAT;\n"
  "      aTimeMax = max (aNodeMin2, aNodeMax2);\n"
  "      aTimeMin = min (aNodeMin2, aNodeMax2);\n"
  "      aTimeLeave = min (aTimeMax.x, min (aTimeMax.y, aTimeMax.z));\n"
  "      aTimeEnter = max (aTimeMin.x, max (aTimeMin.y, aTimeMin.z));\n"
  "      aHitTimes.z = (aTimeEnter <= aTimeLeave && aTimeEnter <= theHit.Time && aTimeLeave >= 0.f && aData.z > 1) ? aTimeEnter : MAXFLOAT;\n"
  "      aTimeMax = max (aNodeMin3, aNodeMax3);\n"
  "      aTimeMin = min (aNodeMin3, aNodeMax3);\n"
  "      aTimeLeave = min (aTimeMax.x, min (aTimeMax.y, aTimeMax.z));\n"
  "      aTimeEnter = max (aTimeMin.x, max (aTimeMin.y, aTimeMin.z));\n"
  "      aHitTimes.w = (aTimeEnter <= aTimeLeave && aTimeEnter <= theHit.Time && aTimeLeave >= 0.f && aData.z > 2) ? aTimeEnter : MAXFLOAT;\n"
  "      ivec4 aChildren = ivec4 (0, 1, 2, 3);\n"
  "      aChildren.xy = aHitTimes.y < aHitTimes.x ? aChildren.yx : aChildren.xy;\n"
  "      aHitTimes.xy = aHitTimes.y < aHitTimes.x ? aHitTimes.yx : aHitTimes.xy;\n"
  "      aChildren.zw = aHitTimes.w < aHitTimes.z ? aChildren.wz : aChildren.zw;\n"
  "      aHitTimes.zw = aHitTimes.w < aHitTimes.z ? aHitTimes.wz : aHitTimes.zw;\n"
  "      aChildren.xz = aHitTimes.z < aHitTimes.x ? aChildren.zx : aChildren.xz;\n"
  "      aHitTimes.xz = aHitTimes.z < aHitTimes.x ? aHitTimes.zx : aHitTimes.xz;\n"
  "      aChildren.yw = aHitTimes.w < aHitTimes.y ? aChildren.wy : aChildren.yw;\n"
  "      aHitTimes.yw = aHitTimes.w < aHitTimes.y ? aHitTimes.wy : aHitTimes.yw;\n"
  "      aChildren.yz = aHitTimes.z < aHitTimes.y ? aChildren.zy : aChildren.yz;\n"
  "      aHitTimes.yz = aHitTimes.z < aHitTimes.y ? aHitTimes.zy : aHitTimes.yz;\n"
  "      if (aHitTimes.x != MAXFLOAT)\n"
  "      {\n"
  "        int aHitMask = (aHitTimes.w != MAXFLOAT ? aChildren.w : aChildren.z) << 2\n"
  "                     | (aHitTimes.z != MAXFLOAT ? aChildren.z : aChildren.y);\n"
  "        if (aHitTimes.y != MAXFLOAT)\n"
  "          Stack[++aHead] = aData.y | (aHitMask << 2 | aChildren.y) << 26;\n"
  "        aNode = aData.y + aChildren.x;\n"
  "      }\n"
  "      else\n"
  "      {\n"
  "        toContinue = (aHead >= 0);\n"
  "        if (aHead == aStop) // go to top-level BVH\n"
  "        {\n"
  "          aStop = -1; aSubTree = SSubTree (theRay, theInverse, EMPTY_ROOT);\n"
  "        }\n"
  "        if (aHead >= 0)\n"
  "          aNode = pop (aHead);\n"
  "      }\n"
  "    }\n"
  "    else if (aData.x < 0) // leaf node (contains triangles)\n"
  "    {\n"
  "      vec3 aNormal;\n"
  "      vec3 aTimeUV;\n"
  "      for (int anIdx = aData.y; anIdx <= aData.z; ++anIdx)\n"
  "      {\n"
  "        ivec4 aTriIndex = texelFetch (uGeometryTriangTexture, anIdx + TRG_OFFSET (aSubTree));\n"
  "        vec3 aPoints[3];\n"
  "        aPoints[0] = texelFetch (uGeometryVertexTexture, aTriIndex.x += VRT_OFFSET (aSubTree)).xyz;\n"
  "        aPoints[1] = texelFetch (uGeometryVertexTexture, aTriIndex.y += VRT_OFFSET (aSubTree)).xyz;\n"
  "        aPoints[2] = texelFetch (uGeometryVertexTexture, aTriIndex.z += VRT_OFFSET (aSubTree)).xyz;\n"
  "        IntersectTriangle (aSubTree.TrsfRay, aPoints[0], aPoints[1], aPoints[2], aTimeUV, aNormal);\n"
  "        if (aTimeUV.x < theHit.Time)\n"
  "        {\n"
  "          aTriangle.TriIndex = aTriIndex;\n"
  "          for (int i = 0; i < 3; ++i)\n"
  "          {\n"
  "            aTriangle.Points[i] = aPoints[i];\n"
  "          }\n"
  "          theTrsfId = TRS_OFFSET (aSubTree);\n"
  "          theHit = SIntersect (aTimeUV.x, aTimeUV.yz, aNormal);\n"
  "        }\n"
  "      }\n"
  "      toContinue = (aHead >= 0);\n"
  "      if (aHead == aStop) // go to top-level BVH\n"
  "      {\n"
  "        aStop = -1; aSubTree = SSubTree (theRay, theInverse, EMPTY_ROOT);\n"
  "      }\n"
  "      if (aHead >= 0)\n"
  "        aNode = pop (aHead);\n"
  "    }\n"
  "    else if (aData.x > 0) // switch node\n"
  "    {\n"
  "      aSubTree.SubData = ivec4 (4 * aData.x - 4, aData.yzw); // store BVH sub-root\n"
  "      vec4 aInvTransf0 = texelFetch (uSceneTransformTexture, TRS_OFFSET (aSubTree) + 0);\n"
  "      vec4 aInvTransf1 = texelFetch (uSceneTransformTexture, TRS_OFFSET (aSubTree) + 1);\n"
  "      vec4 aInvTransf2 = texelFetch (uSceneTransformTexture, TRS_OFFSET (aSubTree) + 2);\n"
  "      vec4 aInvTransf3 = texelFetch (uSceneTransformTexture, TRS_OFFSET (aSubTree) + 3);\n"
  "      aSubTree.TrsfRay.Direct = MatrixColMultiplyDir (theRay.Direct,\n"
  "                                                      aInvTransf0,\n"
  "                                                      aInvTransf1,\n"
  "                                                      aInvTransf2);\n"
  "      aSubTree.Inverse = mix (-UNIT, UNIT, step (ZERO, aSubTree.TrsfRay.Direct)) /\n"
  "        max (abs (aSubTree.TrsfRay.Direct), SMALL);\n"
  "      aSubTree.TrsfRay.Origin = MatrixColMultiplyPnt (theRay.Origin,\n"
  "                                                      aInvTransf0,\n"
  "                                                      aInvTransf1,\n"
  "                                                      aInvTransf2,\n"
  "                                                      aInvTransf3);\n"
  "      aNode = BVH_OFFSET (aSubTree); // go to sub-root node\n"
  "      aStop = aHead; // store current stack pointer\n"
  "    }\n"
  "  }\n"
  "  return aTriangle;\n"
  "}\n"
  "float SceneAnyHit (in SRay theRay, in vec3 theInverse, in float theDistance)\n"
  "{\n"
  "  float aFactor = 1.f;\n"
  "  int aNode =  0; // node to traverse\n"
  "  int aHead = -1; // pointer of stack\n"
  "  int aStop = -1; // BVH level switch\n"
  "  SSubTree aSubTree = SSubTree (theRay, theInverse, EMPTY_ROOT);\n"
  "  for (bool toContinue = true; toContinue; /* none */)\n"
  "  {\n"
  "    ivec4 aData = texelFetch (uSceneNodeInfoTexture, aNode);\n"
  "    if (aData.x == 0) // if inner node\n"
  "    {\n"
  "      aData.y += BVH_OFFSET (aSubTree);\n"
  "      vec4 aHitTimes = vec4 (MAXFLOAT,\n"
  "                             MAXFLOAT,\n"
  "                             MAXFLOAT,\n"
  "                             MAXFLOAT);\n"
  "      vec3 aRayOriginInverse = -aSubTree.TrsfRay.Origin * aSubTree.Inverse;\n"
  "      vec3 aNodeMin0 = texelFetch (uSceneMinPointTexture, aData.y +                0).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aNodeMin1 = texelFetch (uSceneMinPointTexture, aData.y +                1).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aNodeMin2 = texelFetch (uSceneMinPointTexture, aData.y + min (2, aData.z)).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aNodeMin3 = texelFetch (uSceneMinPointTexture, aData.y + min (3, aData.z)).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aNodeMax0 = texelFetch (uSceneMaxPointTexture, aData.y +                0).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aNodeMax1 = texelFetch (uSceneMaxPointTexture, aData.y +                1).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aNodeMax2 = texelFetch (uSceneMaxPointTexture, aData.y + min (2, aData.z)).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aNodeMax3 = texelFetch (uSceneMaxPointTexture, aData.y + min (3, aData.z)).xyz * aSubTree.Inverse + aRayOriginInverse;\n"
  "      vec3 aTimeMax = max (aNodeMin0, aNodeMax0);\n"
  "      vec3 aTimeMin = min (aNodeMin0, aNodeMax0);\n"
  "      float aTimeLeave = min (aTimeMax.x, min (aTimeMax.y, aTimeMax.z));\n"
  "      float aTimeEnter = max (aTimeMin.x, max (aTimeMin.y, aTimeMin.z));\n"
  "      aHitTimes.x = (aTimeEnter <= aTimeLeave && aTimeEnter <= theDistance && aTimeLeave >= 0.f) ? aTimeEnter : MAXFLOAT;\n"
  "      aTimeMax = max (aNodeMin1, aNodeMax1);\n"
  "      aTimeMin = min (aNodeMin1, aNodeMax1);\n"
  "      aTimeLeave = min (aTimeMax.x, min (aTimeMax.y, aTimeMax.z));\n"
  "      aTimeEnter = max (aTimeMin.x, max (aTimeMin.y, aTimeMin.z));\n"
  "      aHitTimes.y = (aTimeEnter <= aTimeLeave && aTimeEnter <= theDistance && aTimeLeave >= 0.f) ? aTimeEnter : MAXFLOAT;\n"
  "      aTimeMax = max (aNodeMin2, aNodeMax2);\n"
  "      aTimeMin = min (aNodeMin2, aNodeMax2);\n"
  "      aTimeLeave = min (aTimeMax.x, min (aTimeMax.y, aTimeMax.z));\n"
  "      aTimeEnter = max (aTimeMin.x, max (aTimeMin.y, aTimeMin.z));\n"
  "      aHitTimes.z = (aTimeEnter <= aTimeLeave && aTimeEnter <= theDistance && aTimeLeave >= 0.f && aData.z > 1) ? aTimeEnter : MAXFLOAT;\n"
  "      aTimeMax = max (aNodeMin3, aNodeMax3);\n"
  "      aTimeMin = min (aNodeMin3, aNodeMax3);\n"
  "      aTimeLeave = min (aTimeMax.x, min (aTimeMax.y, aTimeMax.z));\n"
  "      aTimeEnter = max (aTimeMin.x, max (aTimeMin.y, aTimeMin.z));\n"
  "      aHitTimes.w = (aTimeEnter <= aTimeLeave && aTimeEnter <= theDistance && aTimeLeave >= 0.f && aData.z > 2) ? aTimeEnter : MAXFLOAT;\n"
  "      ivec4 aChildren = ivec4 (0, 1, 2, 3);\n"
  "      aChildren.xy = aHitTimes.y < aHitTimes.x ? aChildren.yx : aChildren.xy;\n"
  "      aHitTimes.xy = aHitTimes.y < aHitTimes.x ? aHitTimes.yx : aHitTimes.xy;\n"
  "      aChildren.zw = aHitTimes.w < aHitTimes.z ? aChildren.wz : aChildren.zw;\n"
  "      aHitTimes.zw = aHitTimes.w < aHitTimes.z ? aHitTimes.wz : aHitTimes.zw;\n"
  "      aChildren.xz = aHitTimes.z < aHitTimes.x ? aChildren.zx : aChildren.xz;\n"
  "      aHitTimes.xz = aHitTimes.z < aHitTimes.x ? aHitTimes.zx : aHitTimes.xz;\n"
  "      aChildren.yw = aHitTimes.w < aHitTimes.y ? aChildren.wy : aChildren.yw;\n"
  "      aHitTimes.yw = aHitTimes.w < aHitTimes.y ? aHitTimes.wy : aHitTimes.yw;\n"
  "      aChildren.yz = aHitTimes.z < aHitTimes.y ? aChildren.zy : aChildren.yz;\n"
  "      aHitTimes.yz = aHitTimes.z < aHitTimes.y ? aHitTimes.zy : aHitTimes.yz;\n"
  "      if (aHitTimes.x != MAXFLOAT)\n"
  "      {\n"
  "        int aHitMask = (aHitTimes.w != MAXFLOAT ? aChildren.w : aChildren.z) << 2\n"
  "                     | (aHitTimes.z != MAXFLOAT ? aChildren.z : aChildren.y);\n"
  "        if (aHitTimes.y != MAXFLOAT)\n"
  "          Stack[++aHead] = aData.y | (aHitMask << 2 | aChildren.y) << 26;\n"
  "        aNode = aData.y + aChildren.x;\n"
  "      }\n"
  "      else\n"
  "      {\n"
  "        toContinue = (aHead >= 0);\n"
  "        if (aHead == aStop) // go to top-level BVH\n"
  "        {\n"
  "          aStop = -1; aSubTree = SSubTree (theRay, theInverse, EMPTY_ROOT);\n"
  "        }\n"
  "        if (aHead >= 0)\n"
  "          aNode = pop (aHead);\n"
  "      }\n"
  "    }\n"
  "    else if (aData.x < 0) // leaf node\n"
  "    {\n"
  "      vec3 aNormal;\n"
  "      vec3 aTimeUV;\n"
  "      for (int anIdx = aData.y; anIdx <= aData.z; ++anIdx)\n"
  "      {\n"
  "        ivec4 aTriangle = texelFetch (uGeometryTriangTexture, anIdx + TRG_OFFSET (aSubTree));\n"
  "        vec3 aPoint0 = texelFetch (uGeometryVertexTexture, aTriangle.x += VRT_OFFSET (aSubTree)).xyz;\n"
  "        vec3 aPoint1 = texelFetch (uGeometryVertexTexture, aTriangle.y += VRT_OFFSET (aSubTree)).xyz;\n"
  "        vec3 aPoint2 = texelFetch (uGeometryVertexTexture, aTriangle.z += VRT_OFFSET (aSubTree)).xyz;\n"
  "        IntersectTriangle (aSubTree.TrsfRay, aPoint0, aPoint1, aPoint2, aTimeUV, aNormal);\n"
  "#ifdef TRANSPARENT_SHADOWS\n"
  "        if (aTimeUV.x < theDistance)\n"
  "        {\n"
  "          aFactor *= 1.f - texelFetch (uRaytraceMaterialTexture, MATERIAL_TRAN (aTriangle.w)).x;\n"
  "        }\n"
  "#else\n"
  "        if (aTimeUV.x < theDistance)\n"
  "        {\n"
  "          aFactor = 0.f;\n"
  "        }\n"
  "#endif\n"
  "      }\n"
  "      toContinue = (aHead >= 0) && (aFactor > 0.1f);\n"
  "      if (aHead == aStop) // go to top-level BVH\n"
  "      {\n"
  "        aStop = -1; aSubTree = SSubTree (theRay, theInverse, EMPTY_ROOT);\n"
  "      }\n"
  "      if (aHead >= 0)\n"
  "        aNode = pop (aHead);\n"
  "    }\n"
  "    else if (aData.x > 0) // switch node\n"
  "    {\n"
  "      aSubTree.SubData = ivec4 (4 * aData.x - 4, aData.yzw); // store BVH sub-root\n"
  "      vec4 aInvTransf0 = texelFetch (uSceneTransformTexture, TRS_OFFSET (aSubTree) + 0);\n"
  "      vec4 aInvTransf1 = texelFetch (uSceneTransformTexture, TRS_OFFSET (aSubTree) + 1);\n"
  "      vec4 aInvTransf2 = texelFetch (uSceneTransformTexture, TRS_OFFSET (aSubTree) + 2);\n"
  "      vec4 aInvTransf3 = texelFetch (uSceneTransformTexture, TRS_OFFSET (aSubTree) + 3);\n"
  "      aSubTree.TrsfRay.Direct = MatrixColMultiplyDir (theRay.Direct,\n"
  "                                                      aInvTransf0,\n"
  "                                                      aInvTransf1,\n"
  "                                                      aInvTransf2);\n"
  "      aSubTree.TrsfRay.Origin = MatrixColMultiplyPnt (theRay.Origin,\n"
  "                                                      aInvTransf0,\n"
  "                                                      aInvTransf1,\n"
  "                                                      aInvTransf2,\n"
  "                                                      aInvTransf3);\n"
  "      aSubTree.Inverse = mix (-UNIT, UNIT, step (ZERO, aSubTree.TrsfRay.Direct)) / max (abs (aSubTree.TrsfRay.Direct), SMALL);\n"
  "      aNode = BVH_OFFSET (aSubTree); // go to sub-root node\n"
  "      aStop = aHead; // store current stack pointer\n"
  "    }\n"
  "  }\n"
  "  return aFactor;\n"
  "}\n"
  "#define PI 3.1415926f\n"
  "vec2 Latlong (in vec3 thePoint, in float theRadius)\n"
  "{\n"
  "  float aPsi = acos (-thePoint.z / theRadius);\n"
  "  float aPhi = atan (thePoint.y, thePoint.x) + PI;\n"
  "  return vec2 (aPhi * 0.1591549f,\n"
  "               aPsi * 0.3183098f);\n"
  "}\n"
  "#ifdef BACKGROUND_CUBEMAP\n"
  "vec3 cubemapVectorTransform (in vec3 theVec, in float theRadius)\n"
  "{\n"
  "  vec3 aVec = theVec.yzx;\n"
  "  aVec.y *= float(uYCoeff);\n"
  "  aVec.z *= float(uZCoeff);\n"
  "  return aVec;\n"
  "}\n"
  "#endif\n"
  "vec3 SmoothNormal (in vec2 theUV, in ivec4 theTriangle)\n"
  "{\n"
  "  vec3 aNormal0 = texelFetch (uGeometryNormalTexture, theTriangle.x).xyz;\n"
  "  vec3 aNormal1 = texelFetch (uGeometryNormalTexture, theTriangle.y).xyz;\n"
  "  vec3 aNormal2 = texelFetch (uGeometryNormalTexture, theTriangle.z).xyz;\n"
  "  return normalize (aNormal1 * theUV.x +\n"
  "                    aNormal2 * theUV.y +\n"
  "                    aNormal0 * (1.0f - theUV.x - theUV.y));\n"
  "}\n"
  "#define POLYGON_OFFSET_UNIT 0.f\n"
  "#define POLYGON_OFFSET_FACTOR 1.f\n"
  "#define POLYGON_OFFSET_SCALE 0.006f\n"
  "float PolygonOffset (in vec3 theNormal, in vec3 thePoint)\n"
  "{\n"
  "  vec4 aProjectedNorm = vec4 (theNormal, -dot (theNormal, thePoint)) * uUnviewMat;\n"
  "  float aPolygonOffset = POLYGON_OFFSET_UNIT;\n"
  "  if (aProjectedNorm.z * aProjectedNorm.z > 1e-20f)\n"
  "  {\n"
  "    aProjectedNorm.xy *= 1.f / aProjectedNorm.z;\n"
  "    aPolygonOffset += POLYGON_OFFSET_FACTOR * max (abs (aProjectedNorm.x),\n"
  "                                                   abs (aProjectedNorm.y));\n"
  "  }\n"
  "  return aPolygonOffset;\n"
  "}\n"
  "#ifdef USE_TEXTURES\n"
  "vec2 SmoothUV (in vec2 theUV, in ivec4 theTriangle, out vec2[3] theUVs)\n"
  "{\n"
  "  theUVs[0] = texelFetch (uGeometryTexCrdTexture, theTriangle.x).st;\n"
  "  theUVs[1] = texelFetch (uGeometryTexCrdTexture, theTriangle.y).st;\n"
  "  theUVs[2] = texelFetch (uGeometryTexCrdTexture, theTriangle.z).st;\n"
  "  return theUVs[1] * theUV.x +\n"
  "         theUVs[2] * theUV.y +\n"
  "         theUVs[0] * (1.0f - theUV.x - theUV.y);\n"
  "}\n"
  "vec2 SmoothUV (in vec2 theUV, in ivec4 theTriangle)\n"
  "{\n"
  "  vec2 aUVs[3];\n"
  "  return SmoothUV (theUV, theTriangle, aUVs);\n"
  "}\n"
  "#endif\n"
  "vec4 FetchEnvironment (in vec3 theTexCoord, in float theRadius, in bool theIsBackground)\n"
  "{\n"
  "  if (uEnvMapEnabled == 0)\n"
  "  {\n"
  "#ifdef PATH_TRACING\n"
  "    return theIsBackground ? vec4 (0.0, 0.0, 0.0, 1.0) : uGlobalAmbient;\n"
  "#else\n"
  "    return vec4 (0.0, 0.0, 0.0, 1.0);\n"
  "#endif\n"
  "  }\n"
  "  vec4 anAmbScale = theIsBackground ? vec4(1.0) : uGlobalAmbient;\n"
  "  vec4 anEnvColor =\n"
  "#ifdef BACKGROUND_CUBEMAP\n"
  "    textureLod (uEnvMapTexture, cubemapVectorTransform (theTexCoord, theRadius), 0.0);\n"
  "#else\n"
  "    textureLod (uEnvMapTexture, Latlong (theTexCoord, theRadius), 0.0);\n"
  "#endif\n"
  "  return anEnvColor * anAmbScale;\n"
  "}\n"
  "#ifndef PATH_TRACING\n"
  "vec3 Refract (in vec3 theInput,\n"
  "              in vec3 theNormal,\n"
  "              in float theRefractIndex,\n"
  "              in float theInvRefractIndex)\n"
  "{\n"
  "  float aNdotI = dot (theInput, theNormal);\n"
  "  float anIndex = aNdotI < 0.0f\n"
  "                ? theInvRefractIndex\n"
  "                : theRefractIndex;\n"
  "  float aSquare = anIndex * anIndex * (1.0f - aNdotI * aNdotI);\n"
  "  if (aSquare > 1.0f)\n"
  "  {\n"
  "    return reflect (theInput, theNormal);\n"
  "  }\n"
  "  float aNdotT = sqrt (1.0f - aSquare);\n"
  "  return normalize (anIndex * theInput -\n"
  "    (anIndex * aNdotI + (aNdotI < 0.0f ? aNdotT : -aNdotT)) * theNormal);\n"
  "}\n"
  "#endif\n"
  "#define MIN_SLOPE 0.0001f\n"
  "#define EPS_SCALE 8.0000f\n"
  "#define THRESHOLD vec3 (0.1f)\n"
  "#define INVALID_BOUNCES 1000\n"
  "#define LIGHT_POS(index) (2 * index + 1)\n"
  "#define LIGHT_PWR(index) (2 * index + 0)\n"
  "#ifndef PATH_TRACING\n"
  "vec4 Radiance (in SRay theRay, in vec3 theInverse)\n"
  "{\n"
  "  vec3 aResult = vec3 (0.0f);\n"
  "  vec4 aWeight = vec4 (1.0f);\n"
  "  int aTrsfId;\n"
  "  float aRaytraceDepth = MAXFLOAT;\n"
  "  float aRefractionIdx = 0.0;\n"
  "  for (int aDepth = 0; aDepth < NB_BOUNCES; ++aDepth)\n"
  "  {\n"
  "    SIntersect aHit = SIntersect (MAXFLOAT, vec2 (ZERO), ZERO);\n"
  "    ivec4 aTriIndex = SceneNearestHit (theRay, theInverse, aHit, aTrsfId).TriIndex;\n"
  "    if (aTriIndex.x == -1)\n"
  "    {\n"
  "      vec4 aColor = vec4 (0.0);\n"
  "      if (bool(uEnvMapForBack) || aWeight.w == 0.0 /* reflection */)\n"
  "      {\n"
  "        float aRadius = uSceneRadius;\n"
  "        vec3 aTexCoord = vec3 (0.0);\n"
  "        if (aDepth == 0 || (aRefractionIdx == 1.0 && aWeight.w != 0.0))\n"
  "        {\n"
  "          vec2 aPixel = uEyeSize * (vPixel - vec2 (0.5)) * 2.0;\n"
  "          vec2 anAperturePnt = sampleUniformDisk() * uApertureRadius;\n"
  "          vec3 aLocalDir = normalize (vec3 (aPixel * uFocalPlaneDist - anAperturePnt, uFocalPlaneDist));\n"
  "          vec3 aDirect = uEyeView * aLocalDir.z +\n"
  "                         uEyeSide * aLocalDir.x +\n"
  "                         uEyeVert * aLocalDir.y;\n"
  "          \n"
  "          aTexCoord = aDirect * uSceneRadius;\n"
  "          aRadius = length (aTexCoord);\n"
  "        }\n"
  "        else\n"
  "        {\n"
  "          float aTime = IntersectSphere (theRay, uSceneRadius);\n"
  "          aTexCoord = theRay.Direct * aTime + theRay.Origin;\n"
  "        }\n"
  "        aColor = FetchEnvironment (aTexCoord, aRadius, aWeight.w != 0.0);\n"
  "      }\n"
  "      else\n"
  "      {\n"
  "        aColor = BackgroundColor();\n"
  "      }\n"
  "      aResult += aWeight.xyz * aColor.xyz; aWeight.w *= aColor.w;\n"
  "      break; // terminate path\n"
  "    }\n"
  "    vec3 aInvTransf0 = texelFetch (uSceneTransformTexture, aTrsfId + 0).xyz;\n"
  "    vec3 aInvTransf1 = texelFetch (uSceneTransformTexture, aTrsfId + 1).xyz;\n"
  "    vec3 aInvTransf2 = texelFetch (uSceneTransformTexture, aTrsfId + 2).xyz;\n"
  "    aHit.Normal = normalize (vec3 (dot (aInvTransf0, aHit.Normal),\n"
  "                                   dot (aInvTransf1, aHit.Normal),\n"
  "                                   dot (aInvTransf2, aHit.Normal)));\n"
  "    theRay.Origin += theRay.Direct * aHit.Time; // intersection point\n"
  "    // Evaluate depth on first hit\n"
  "    if (aDepth == 0)\n"
  "    {\n"
  "      vec4 aNDCPoint = uViewMat * vec4 (theRay.Origin, 1.f);\n"
  "      float aPolygonOffset = PolygonOffset (aHit.Normal, theRay.Origin);\n"
  "    #ifdef THE_ZERO_TO_ONE_DEPTH\n"
  "      aRaytraceDepth = (aNDCPoint.z / aNDCPoint.w + aPolygonOffset * POLYGON_OFFSET_SCALE);\n"
  "    #else\n"
  "      aRaytraceDepth = (aNDCPoint.z / aNDCPoint.w + aPolygonOffset * POLYGON_OFFSET_SCALE) * 0.5f + 0.5f;\n"
  "    #endif\n"
  "    }\n"
  "    vec3 aNormal = SmoothNormal (aHit.UV, aTriIndex);\n"
  "    aNormal = normalize (vec3 (dot (aInvTransf0, aNormal),\n"
  "                               dot (aInvTransf1, aNormal),\n"
  "                               dot (aInvTransf2, aNormal)));\n"
  "    vec3 aAmbient  = texelFetch (\n"
  "      uRaytraceMaterialTexture, MATERIAL_AMBN (aTriIndex.w)).rgb;\n"
  "    vec4 aDiffuse  = texelFetch (\n"
  "      uRaytraceMaterialTexture, MATERIAL_DIFF (aTriIndex.w));\n"
  "    vec4 aSpecular = texelFetch (\n"
  "      uRaytraceMaterialTexture, MATERIAL_SPEC (aTriIndex.w));\n"
  "    vec4 aOpacity  = texelFetch (\n"
  "      uRaytraceMaterialTexture, MATERIAL_TRAN (aTriIndex.w));\n"
  "#ifdef USE_TEXTURES\n"
  "    if (aDiffuse.w >= 0.f)\n"
  "    {\n"
  "      vec4 aTexCoord = vec4 (SmoothUV (aHit.UV, aTriIndex), 0.f, 1.f);\n"
  "      vec4 aTrsfRow1 = texelFetch (\n"
  "        uRaytraceMaterialTexture, MATERIAL_TRS1 (aTriIndex.w));\n"
  "      vec4 aTrsfRow2 = texelFetch (\n"
  "        uRaytraceMaterialTexture, MATERIAL_TRS2 (aTriIndex.w));\n"
  "      aTexCoord.st = vec2 (dot (aTrsfRow1, aTexCoord),\n"
  "                           dot (aTrsfRow2, aTexCoord));\n"
  "      vec4 aTexColor = textureLod (\n"
  "        sampler2D (uTextureSamplers[int(aDiffuse.w)]), aTexCoord.st, 0.f);\n"
  "      aDiffuse.rgb *= aTexColor.rgb;\n"
  "      aAmbient.rgb *= aTexColor.rgb;\n"
  "      // keep refractive index untouched (Z component)\n"
  "      aOpacity.xy = vec2 (aTexColor.w * aOpacity.x, 1.0f - aTexColor.w * aOpacity.x);\n"
  "    }\n"
  "#endif\n"
  "    vec3 aEmission = texelFetch (\n"
  "      uRaytraceMaterialTexture, MATERIAL_EMIS (aTriIndex.w)).rgb;\n"
  "    float aGeomFactor = dot (aNormal, theRay.Direct);\n"
  "    aResult.xyz += aWeight.xyz * aOpacity.x * (\n"
  "      uGlobalAmbient.xyz * aAmbient * max (abs (aGeomFactor), 0.5f) + aEmission);\n"
  "    vec3 aSidedNormal = mix (aNormal, -aNormal, step (0.0f, aGeomFactor));\n"
  "    for (int aLightIdx = 0; aLightIdx < uLightCount; ++aLightIdx)\n"
  "    {\n"
  "      vec4 aLight = texelFetch (\n"
  "        uRaytraceLightSrcTexture, LIGHT_POS (aLightIdx));\n"
  "      float aDistance = MAXFLOAT;\n"
  "      if (aLight.w != 0.0f) // point light source\n"
  "      {\n"
  "        aDistance = length (aLight.xyz -= theRay.Origin);\n"
  "        aLight.xyz *= 1.0f / aDistance;\n"
  "      }\n"
  "      float aLdotN = dot (aLight.xyz, aSidedNormal);\n"
  "      if (aLdotN > 0.0f) // first check if light source is important\n"
  "      {\n"
  "        float aVisibility = 1.0f;\n"
  "        if (bool(uShadowsEnabled))\n"
  "        {\n"
  "          SRay aShadow = SRay (theRay.Origin, aLight.xyz);\n"
  "          aShadow.Origin += uSceneEpsilon * (aLight.xyz +\n"
  "            mix (-aHit.Normal, aHit.Normal, step (0.0f, dot (aHit.Normal, aLight.xyz))));\n"
  "          vec3 aInverse = 1.0f / max (abs (aLight.xyz), SMALL);\n"
  "          aVisibility = SceneAnyHit (\n"
  "            aShadow, mix (-aInverse, aInverse, step (ZERO, aLight.xyz)), aDistance);\n"
  "        }\n"
  "        if (aVisibility > 0.0f)\n"
  "        {\n"
  "          vec3 aIntensity = min (UNIT, vec3 (texelFetch (\n"
  "            uRaytraceLightSrcTexture, LIGHT_PWR (aLightIdx))));\n"
  "          float aRdotV = dot (reflect (aLight.xyz, aSidedNormal), theRay.Direct);\n"
  "          aResult.xyz += aWeight.xyz * (aOpacity.x * aVisibility) * aIntensity *\n"
  "            (aDiffuse.xyz * aLdotN + aSpecular.xyz * pow (max (0.f, aRdotV), aSpecular.w));\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "    if (aOpacity.x != 1.0f)\n"
  "    {\n"
  "      aWeight *= aOpacity.y;\n"
  "      aRefractionIdx = aOpacity.z;\n"
  "      if (aOpacity.z != 1.0f)\n"
  "      {\n"
  "        theRay.Direct = Refract (theRay.Direct, aNormal, aOpacity.z, aOpacity.w);\n"
  "      }\n"
  "    }\n"
  "    else\n"
  "    {\n"
  "      aWeight *= bool(uReflectEnabled) ?\n"
  "        texelFetch (uRaytraceMaterialTexture, MATERIAL_REFL (aTriIndex.w)) : vec4 (0.0f);\n"
  "      vec3 aReflect = reflect (theRay.Direct, aNormal);\n"
  "      if (dot (aReflect, aHit.Normal) * dot (theRay.Direct, aHit.Normal) > 0.0f)\n"
  "      {\n"
  "        aReflect = reflect (theRay.Direct, aHit.Normal);\n"
  "      }\n"
  "      theRay.Direct = aReflect;\n"
  "    }\n"
  "    if (all (lessThanEqual (aWeight.xyz, THRESHOLD)))\n"
  "    {\n"
  "      aDepth = INVALID_BOUNCES;\n"
  "    }\n"
  "    else if (aOpacity.x == 1.0f || aOpacity.z != 1.0f) // if no simple transparency\n"
  "    {\n"
  "      theRay.Origin += aHit.Normal * mix (\n"
  "        -uSceneEpsilon, uSceneEpsilon, step (0.0f, dot (aHit.Normal, theRay.Direct)));\n"
  "      theInverse = 1.0f / max (abs (theRay.Direct), SMALL);\n"
  "      theInverse = mix (-theInverse, theInverse, step (ZERO, theRay.Direct));\n"
  "    }\n"
  "    theRay.Origin += theRay.Direct * uSceneEpsilon;\n"
  "  }\n"
  "  gl_FragDepth = aRaytraceDepth;\n"
  "  return vec4 (aResult.x,\n"
  "               aResult.y,\n"
  "               aResult.z,\n"
  "               aWeight.w);\n"
  "}\n"
  "#endif\n";
